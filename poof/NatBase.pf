union Nat {
  zero;
  suc(Nat);
}

function add(Nat,Nat) -> Nat {
  add(zero, m) = m;
  add(suc(n), m) = suc(add(n, m));
}

theorem add_zero: all n:Nat. add(n, zero) = n
proof
  induction Nat
  case zero {
    have add(zero, zero) = zero by reflexive
  }
  case suc(n') {
    transitive have add(suc(n'), zero) = suc(add(n', zero)) by reflexive
               have suc(add(n', zero)) = suc(n') by rewrite IH then reflexive
  }
end

theorem add_suc: all m:Nat. all n:Nat. add(m, suc(n)) = suc(add(m,n))
proof
  induction Nat
  case zero {
    any n : Nat {
      reflexive
    }
  }
  case suc(n') {
    any n : Nat {
      have add(suc(n'),suc(n)) = suc(add(suc(n'),n)) by
      transitive have add(suc(n'),suc(n)) = suc(add(n',suc(n))) by reflexive
      transitive have suc(add(n',suc(n))) = suc(suc(add(n',n))) by rewrite IH[n] then reflexive
                 have suc(suc(add(n',n))) = suc(add(suc(n'),n)) by reflexive
    }
  }
end  

theorem add_commute: all n:Nat. all m:Nat. add(n,m) = add(m,n)
proof
  induction Nat
  case zero {
    any m : Nat {
      have add(zero,m) = add(m,zero) by
      transitive have add(zero,m) = m by reflexive
                 have m = add(m,zero) by symmetric add_zero[m]
    }
  }
  case suc(n') {
    any m : Nat {
      have add(suc(n'),m) = add(m,suc(n')) by
      transitive have add(suc(n'),m) = suc(add(n',m)) by reflexive
      transitive have suc(add(n',m)) = suc(add(m,n')) by rewrite IH[m] then reflexive
                 have suc(add(m,n')) = add(m,suc(n')) by symmetric add_suc[m][n']
    }
  }
end

theorem add_assoc: all m:Nat. all n:Nat, o:Nat.
  add(add(m,n),o) = add(m,add(n,o))
proof
  induction Nat
  case zero {
    any n:Nat, o:Nat {
      have add(add(zero,n),o) = add(zero,add(n,o)) by reflexive
    }
  }
  case suc(m') {
    any n:Nat, o:Nat {
      have add(add(suc(m'),n),o) = add(suc(m'),add(n,o)) by
      transitive have add(add(suc(m'),n),o) = suc(add(add(m',n),o)) by reflexive
      transitive have suc(add(add(m',n),o)) = suc(add(m',add(n,o))) by rewrite IH[n,o] then reflexive
                 have suc(add(m',add(n,o))) = add(suc(m'),add(n,o)) by reflexive
    }
  }
end

theorem left_cancel: all x:Nat. all y:Nat, z:Nat.
  if add(x,y) = add(x,z) then y = z
proof
  induction Nat
  case zero {
    any y:Nat, z:Nat {
      suppose prem: add(zero,y) = add(zero,z)  {
        transitive have y = add(zero,y) by reflexive
	transitive have add(zero,y) = add(zero,z) by prem
	           have add(zero,z) = z by reflexive
      }
    }
  }
  case suc(x') {
    any y:Nat, z:Nat {
      suppose prem: add(suc(x'),y) = add(suc(x'),z) {
	p1: suc(add(x', y)) = suc(add(x',z)) by
	  transitive have suc(add(x', y)) = add(suc(x'),y) by reflexive
	  transitive prem reflexive;
	p2: add(x',y) = add(x',z) by injective p1;
        IHyz: if add(x',y) = add(x',z) then y = z by IH[y,z];
        apply IHyz with p2
      }
    }
  }
end

function pred(Nat) -> Nat {
  pred(zero) = zero;
  pred(suc(n)) = n;
}

theorem pred_one: pred(suc(zero)) = zero
proof
  reflexive
end

function sub(Nat,Nat) -> Nat {
  sub(zero, m) = zero;
  sub(suc(n), m) = switch m {
                     case zero { suc(n) }
                     case suc(m') { sub(n, m') }
		   };
}

function sub_from(Nat,Nat) -> Nat {
  sub_from(zero, m) = m;
  sub_from(suc(n), m) = sub_from(n, pred(m));
}

theorem sub_one_one: sub(suc(zero), suc(zero)) = zero
proof
  reflexive
end

function less_equal(Nat,Nat) -> bool {
  less_equal(zero, m) = true;
  less_equal(suc(n'), m) =
    switch m {
      case zero { false }
      case suc(m') { less_equal(n', m') }
    };
}

theorem less_equal_refl: all n:Nat. less_equal(n,n)
proof
  induction Nat
  case zero { . }
  case suc(n') { IH }
end
