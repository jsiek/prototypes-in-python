union Nat {
  zero;
  suc(Nat);
}

function +(Nat,Nat) -> Nat {
  +(zero, m) = m;
  +(suc(n), m) = suc(n + m);
}

theorem add_zero: all n:Nat. n + zero = n
proof
  induction Nat
  case zero {
    have zero + zero = zero by reflexive
  }
  case suc(n') {
    transitive have suc(n') + zero = suc(n' + zero) by reflexive
               have suc(n' + zero) = suc(n')
	                          by rewrite goal with IH then reflexive
  }
end

theorem add_suc: all m:Nat. all n:Nat. m + suc(n) = suc(m + n)
proof
  induction Nat
  case zero {
    any n : Nat;
    reflexive
  }
  case suc(n') {
    any n : Nat;
    have suc(n') + suc(n) = suc(suc(n') + n) by
    transitive have suc(n') + suc(n) = suc(n' + suc(n)) by reflexive
    transitive have suc(n' + suc(n)) = suc(suc(n' + n))
                                 by rewrite goal with IH[n] then reflexive
               have suc(suc(n' + n)) = suc(suc(n') + n) by reflexive
  }
end  

theorem add_commute: all n:Nat. all m:Nat. n + m = m + n
proof
  induction Nat
  case zero {
    any m : Nat;
    have zero + m = m + zero by
    transitive have zero + m = m by reflexive
               have m = m + zero by symmetric add_zero[m]
  }
  case suc(n') {
    any m : Nat;
    have suc(n') + m = m + suc(n') by
    transitive have suc(n') + m = suc(n' + m) by reflexive
    transitive have suc(n' + m) = suc(m + n')
		   by rewrite goal with IH[m] then reflexive
	       have suc(m + n') = m + suc(n')
		   by symmetric add_suc[m][n']
  }
end

theorem add_assoc: all m:Nat. all n:Nat, o:Nat.
  (m + n) + o = m + (n + o)
proof
  induction Nat
  case zero {
    any n:Nat, o:Nat;
    have (0 + n) + o = 0 + (n + o) by reflexive
  }
  case suc(m') {
    any n:Nat, o:Nat;
    have (suc(m') + n) + o = suc(m') + (n + o) by
    transitive have (suc(m') + n) + o = suc((m' + n) + o) by reflexive
    transitive have suc((m' + n) + o) = suc(m' + (n + o))
                                   by rewrite goal with IH[n,o] then reflexive
	       have suc(m' + (n + o)) = suc(m') + (n + o) by reflexive
  }
end

theorem left_cancel: all x:Nat. all y:Nat, z:Nat.
  if x + y = x + z then y = z
proof
  induction Nat
  case zero {
    any y:Nat, z:Nat;
    suppose prem: zero + y = zero + z;
    transitive have y = zero + y by reflexive
    transitive have zero + y = zero + z by prem
	       have zero + z = z by reflexive
  }
  case suc(x') {
    any y:Nat, z:Nat;
    suppose prem: suc(x') + y = suc(x') + z;
    p1: suc(x' +  y) = suc(x' + z) by
      transitive have suc(x' +  y) = suc(x') + y by reflexive
      transitive prem reflexive;
    p2: x' + y = x' + z by injective p1;
    IHyz: if x' + y = x' + z then y = z by IH[y,z];
    apply IHyz with p2
  }
end

function pred(Nat) -> Nat {
  pred(zero) = zero;
  pred(suc(n)) = n;
}

theorem pred_one: pred(suc(zero)) = zero
proof
  reflexive
end

function sub(Nat,Nat) -> Nat {
  sub(zero, m) = zero;
  sub(suc(n), m) = switch m {
                     case zero { suc(n) }
                     case suc(m') { sub(n, m') }
                   };
}

function sub_from(Nat,Nat) -> Nat {
  sub_from(zero, m) = m;
  sub_from(suc(n), m) = sub_from(n, pred(m));
}

theorem sub_one_one: sub(suc(zero), suc(zero)) = zero
proof
  reflexive
end

function less_equal(Nat,Nat) -> bool {
  less_equal(zero, m) = true;
  less_equal(suc(n'), m) =
    switch m {
      case zero { false }
      case suc(m') { less_equal(n', m') }
    };
}

theorem less_equal_refl: all n:Nat. less_equal(n,n)
proof
  induction Nat
  case zero { . }
  case suc(n') { IH }
end

theorem less_equal_trans: all m:Nat. all n:Nat, o:Nat.
  if less_equal(m,n) and less_equal(n,o) then less_equal(m,o)
proof
  induction Nat
  case zero {
    any n:Nat, o:Nat;
    suppose _;
    have less_equal(zero,o) by .
  }
  case suc(m') {
    any n:Nat, o:Nat;
    suppose p;
    sm_n: less_equal(suc(m'), n) by p;
    n_o: less_equal(n,o) by p;
    switch n {
      case zero {
        sm_z: less_equal(suc(m'),zero) by rewrite sm_n with EQ;
        have false by sm_z
      }
      case suc(n') {
        sm_sn: less_equal(suc(m'),suc(n')) by rewrite sm_n with EQ;
        m_n: less_equal(m', n') by sm_sn;
        sn_o: less_equal(suc(n'),o) by rewrite n_o with EQ;
        switch o {
          case zero {
            sn_z: less_equal(suc(n'), zero) by rewrite sn_o with EQ;
            have false by sn_z
          }
          case suc(o') {
            sn_so: less_equal(suc(n'),suc(o')) by rewrite sn_o with EQ;
            n_o: less_equal(n',o') by sn_so;
            rewrite goal with EQ then apply IH[n',o'] with m_n, n_o
          }
        }
      }
    }
  }
end